{-# LANGUAGE QuasiQuotes #-}

module Ivory.Compile.C.Modules where

import Paths_ivory_backend_c (version)

import qualified Text.PrettyPrint.Mainland as PP
import Text.PrettyPrint.Mainland

import qualified Ivory.Language.Syntax.AST as I
--import qualified Ivory.Language as L

import Ivory.Compile.C.Gen
import Ivory.Compile.C.Types

import Data.Char (toUpper)
import Data.Version (showVersion)
import Control.Applicative ((<$>))
import qualified Data.Set as S
import Control.Monad
import System.IO
import System.FilePath ((<.>))
import MonadLib (put,runM)

--------------------------------------------------------------------------------

showModule :: FilePath -> CompileUnits -> [[String]]
showModule rtPath m =
  [ mk "// Sources:\n" (sources m)
  , mk "// Header:\n"  (headers m)
  , mk "// Externs:\n" (S.empty, externs m)
  ]
  where
  mk _   (_,[])         = []
  mk str (incls,units)  = str : pp (map (includeDef rtPath) (S.toList incls) ++ units)
  pp = map (show . ppr)

--------------------------------------------------------------------------------

compilerVersion :: String
compilerVersion = showVersion version

---
topComments :: Doc
topComments  = text "/* This file has been autogenerated by Ivory" </>
               text " * Compiler version " <+> text compilerVersion </>
               text " */"

-- | Output header file for a module.
writeHdr :: Bool                -- ^ Verbosity
         -> FilePath            -- ^ Ivory runtime include path
         -> FilePath            -- ^ Output file name
         -> (Includes, Sources) -- ^ Source to translate
         -> String              -- ^ Unit name
         -> IO ()
writeHdr verbose rtPath f s unitname = case verbose of
    True  -> toFile f guardedHeader
    False -> toFileQuiet f guardedHeader
  where
  guardedHeader = stack [ topComments
                        , topGuard
                        , topExternC
                        , ppr (defs s)
                        , botExternC
                        , botGuard
                        ]
  topGuard        = text "#ifndef" <+> guardName PP.</> text "#define"
                      <+> guardName
  botGuard        = text "#endif" <+> text "/*" <+> guardName <+> text "*/"
  unitname'       = map (\c -> if c == '-' then '_' else c) unitname
  guardName       = text "__" <> text (toUpper <$> unitname') <> text "_H__"
  topExternC      = stack $ text <$> [ "#ifdef __cplusplus"
                                     , "extern \"C\" {"
                                     , "#endif"]
  botExternC      = stack $ text <$> [ "#ifdef __cplusplus"
                                     , "}"
                                     , "#endif"]
  defs (incls,us) = map (includeDef rtPath) (S.toList incls) ++ us


-- | Output source file for a module.
writeSrc :: Bool                 -- ^ Be verbose
         -> FilePath             -- ^ Path to runtime includes
         -> FilePath             -- ^ Output source name
         -> (Includes, Sources)  -- ^ Module to translate
         -> IO ()
writeSrc verbose rtPath f s = vToFile f (topComments </> out)
  where
  vToFile = if verbose then toFile else toFileQuiet
  defs (incls,us) = map (includeDef rtPath) (S.toList incls) ++ us
  out = stack $ punctuate line $ map ppr $ defs s

-- Utility
toFileQuiet :: FilePath -> Doc -> IO ()
toFileQuiet f v = do
  let putf h = PP.hPutDoc h v
  withFile f WriteMode putf

toFile :: FilePath -> Doc -> IO ()
toFile f v = do
  putStr $ "Writing to file " ++ f ++ "..."
  toFileQuiet f v
  putStrLn " Done."

--------------------------------------------------------------------------------

runOpt :: (I.Proc -> I.Proc) -> I.Module -> I.Module
runOpt opt m =
  m { I.modProcs = procs' }
  where
  procs' = procs { I.public = map' I.public, I.private = map' I.private }
  procs = I.modProcs m
  map' acc = map opt (acc procs)

--------------------------------------------------------------------------------

-- | Compile a module.
compileModule :: I.Module -> CompileUnits
compileModule I.Module { I.modName    = nm
                       , I.modDepends = deps
                       , I.modHeaders = hdrs
                       , I.modExterns = exts
                       , I.modImports = imports
                       , I.modProcs   = procs
                       , I.modStructs = structs
                       , I.modAreas       = areas
                       , I.modAreaImports = ais
                       }
  = CompileUnits
  { unitName = nm
  , sources  = sources res
  , headers  = headers res
  , externs  = externs res
  }
  where
  res     = compRes comp
  compRes = (snd . runM . unCompile)

  unitHdr = LocalInclude (nm <.> "h")

  comp = do
    let c = compRes comp0
    unless (null (snd (headers c))) (putSrcInc unitHdr)
    Compile (put c)

  ivoryHdr = RtInclude "runtime/ivory.h"

  comp0 :: Compile
  comp0 = do
    putHdrInc ivoryHdr
    -- module names don't have a .h on the end
    mapM_ (putHdrInc . LocalInclude . ((<.> "h"))) (S.toList deps)
    mapM_ (putHdrInc . SysInclude)   (S.toList hdrs)
    mapM_ (compileStruct Public) (I.public structs)
    mapM_ (compileStruct Private) (I.private structs)
    mapM_ compileExtern exts
    mapM_ fromImport imports
    mapM_ (compileArea Public) (I.public areas)
    mapM_ (compileArea Private) (I.private areas)
    mapM_ compileAreaImport ais
    mapM_ (extractProto Public) (I.public procs)
    mapM_ (extractProto Private) (I.private procs)
    mapM_ compileUnit (I.public procs ++ I.private procs)

--------------------------------------------------------------------------------

fromImport :: I.Import -> Compile
fromImport p = putSrcInc (SysInclude (I.importFile p))

--------------------------------------------------------------------------------

outputProcSyms :: [I.Module] -> IO ()
outputProcSyms mods = putStrLn $ unwords $ concatMap go mods
  where
  go :: I.Module -> [String]
  go m = map I.procSym (pub ++ priv)
    where I.Visible pub priv = I.modProcs m

--------------------------------------------------------------------------------
