{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE MultiParamTypeClasses #-}

-- Autogenerated Mavlink v1.0 implementation: see smavgen_ivory.py

module Heartbeat where

import Ivory.Serialize
-- import SMACCMPilot.Mavlink.Unpack
-- import SMACCMPilot.Mavlink.Send

import Ivory.Language
import Ivory.Stdlib

heartbeatMsgId :: Uint8
heartbeatMsgId = 0

heartbeatCrcExtra :: Uint8
heartbeatCrcExtra = 50

heartbeatModule :: Module
heartbeatModule = package "mavlink_heartbeat_msg" $ do
  depend serializeModule
  -- depend mavlinkSendModule
  -- incl mkHeartbeatSender
  incl packUnpack
  incl heartbeatPack
  incl heartbeatUnpack
  defStruct (Proxy :: Proxy "heartbeat_msg")
  defStruct (Proxy :: Proxy "mavlinkPacket")

[ivory|
struct heartbeat_msg
  { custom_mode :: Stored Uint8 -- Uint32
  ; mavtype :: Stored Uint8
  ; autopilot :: Stored Uint8
  ; base_mode :: Stored Uint8
  ; system_status :: Stored Uint8
  ; mavlink_version :: Stored Uint8
  }
|]

-- mkHeartbeatSender ::
--   Def ('[ ConstRef s0 (Struct "heartbeat_msg")
--         , Ref s1 (Stored Uint8) -- seqNum
--         , Ref s1 (Struct "mavlinkPacket") -- tx buffer/length
--         ] :-> ())
-- mkHeartbeatSender =
--   proc "mavlink_heartbeat_msg_send"
--   $ \msg seqNum sendStruct -> body
--   $ do
--   arr <- local (iarray [] :: Init (Array 9 (Stored Uint8)))
--   let buf = toCArray arr
--   pack buf 0 =<< deref (msg ~> custom_mode)
--   pack buf 4 =<< deref (msg ~> mavtype)
--   pack buf 5 =<< deref (msg ~> autopilot)
--   pack buf 6 =<< deref (msg ~> base_mode)
--   pack buf 7 =<< deref (msg ~> system_status)
--   pack buf 8 =<< deref (msg ~> mavlink_version)
--   -- 6: header len, 2: CRC len
--   let usedLen    = 6 + 9 + 2 :: Integer
--   let sendArr    = sendStruct ~> mav_array
--   let sendArrLen = arrayLen sendArr
--   if sendArrLen < usedLen
--     then error "heartbeat payload of length 9 is too large!"
--     else do -- Copy, leaving room for the payload
--             arrayCopy sendArr arr 6 (arrayLen arr)
--             call_ mavlinkSendWithWriter
--                     heartbeatMsgId
--                     heartbeatCrcExtra
--                     9
--                     seqNum
--                     sendStruct

-- instance MavlinkUnpackableMsg "heartbeat_msg" where
--     unpackMsg = ( heartbeatUnpack , heartbeatMsgId )

packUnpack :: Def ('[Ref s1 (Struct "heartbeat_msg")] :-> ())
packUnpack = proc "pack_unpack" $ \ msg -> body $ do
  buf <- local (iarray [] :: Init (Array 9 (Stored Uint8)))
  call_ heartbeatPack (constRef msg) buf
  msg' <- local (istruct [] :: Init (Struct "heartbeat_msg"))
  call_ heartbeatUnpack msg' (constRef buf)
  cm1 <- deref (msg ~> custom_mode)
  cm2 <- deref (msg' ~> custom_mode)
  mt1 <- deref (msg ~> mavtype)
  mt2 <- deref (msg' ~> mavtype)
  ap1 <- deref (msg ~> autopilot)
  ap2 <- deref (msg' ~> autopilot)
  bm1 <- deref (msg ~> base_mode)
  bm2 <- deref (msg' ~> base_mode)
  ss1 <- deref (msg ~> system_status)
  ss2 <- deref (msg' ~> system_status)
  mv1 <- deref (msg ~> mavlink_version)
  mv2 <- deref (msg' ~> mavlink_version)
  assert (cm1 ==? cm2 .&& mt1 ==? mt2 .&& ap1 ==? ap2 .&&
          bm1 ==? bm2 .&& ss1 ==? ss2 .&& mv1 ==? mv2)
  retVoid

heartbeatUnpack :: Def ('[ Ref s1 (Struct "heartbeat_msg")
                         , ConstRef s2 (Array 9 (Stored Uint8))
                         ] :-> () )
heartbeatUnpack = proc "heartbeat_unpack" $ \ msg buf -> body $ do
  store (msg ~> custom_mode)     =<< deref (buf ! 0)
  store (msg ~> mavtype)         =<< deref (buf ! 4)
  store (msg ~> autopilot)       =<< deref (buf ! 5)
  store (msg ~> base_mode)       =<< deref (buf ! 6)
  store (msg ~> system_status)   =<< deref (buf ! 7)
  store (msg ~> mavlink_version) =<< deref (buf ! 8)

heartbeatPack ::
  Def ('[ ConstRef s0 (Struct "heartbeat_msg")
        , Ref s1 (Array 9 (Stored Uint8))
        -- , Ref s1 (Stored Uint8) -- seqNum
        -- , Ref s1 (Struct "mavlinkPacket") -- tx buffer/length
        ] :-> ())
heartbeatPack =
  proc "heartbeat_pack"
  $ \msg buf -> body
  $ do
  -- arr <- local (iarray [] :: Init (Array 9 (Stored Uint8)))
  -- let buf = toCArray arr
  store (buf ! 0) =<< deref (msg ~> custom_mode)
  store (buf ! 4) =<< deref (msg ~> mavtype)
  store (buf ! 5) =<< deref (msg ~> autopilot)
  store (buf ! 6) =<< deref (msg ~> base_mode)
  store (buf ! 7) =<< deref (msg ~> system_status)
  store (buf ! 8) =<< deref (msg ~> mavlink_version)
  retVoid
  -- 6: header len, 2: CRC len
  -- let usedLen    = 6 + 9 + 2 :: Integer
  -- let sendArr    = sendStruct ~> mav_array
  -- let sendArrLen = arrayLen sendArr
  -- if sendArrLen < usedLen
  --   then error "heartbeat payload of length 9 is too large!"
  --   else do -- Copy, leaving room for the payload
  --           arrayCopy sendArr arr 6 (arrayLen arr)
  --           call_ mavlinkSendWithWriter
  --                   heartbeatMsgId
  --                   heartbeatCrcExtra
  --                   9
  --                   seqNum
  --                   sendStruct

--------------------------------------------------------------------------------
-- SMACCMPilot.Mavlink.Send
--------------------------------------------------------------------------------
[ivory|
struct mavlinkPacket
  { mav_array :: Array 80 (Stored Uint8) -- C. CommsecArray
  ; mav_size  :: Stored Uint8
  }
|]

mavlinkSendWithWriter ::
  Def ('[ Uint8 -- msgID
        , Uint8 -- crcExtra
        , Uint8 -- payload length
        , Ref s (Stored Uint8) -- sequence number (use then increment)
        , Ref s (Struct "mavlinkPacket") -- what we'll put everything into
        ] :-> ())
mavlinkSendWithWriter =
  proc "mavlinkSendWithWriter"
  $ \msgId crcExtra payloadLen seqNum struct -> body
  $ do
    retVoid
    
--------------------------------------------------------------------------------
-- SMACCMPilot.Mavlink.Unpack
--------------------------------------------------------------------------------
class MavlinkUnpackableMsg t where
  unpackMsg :: ( Def ('[ Ref s1 (Struct t)
                       , ConstRef s2 (CArray (Stored Uint8))
                       ] :-> ())
                , Uint8 )
