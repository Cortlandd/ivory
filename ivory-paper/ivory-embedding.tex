\section{Ivory Embedding}
\label{sec:ivory-embedding}

In this section, we describe the implementation of Ivory, focusing on embedding
the Ivory type system in the GHC type system.

\subsection{The Ivory Monad}
\label{sec:ivory-monad}

Ivory is a monadic language, in which Ivory statements have effects in the Ivory
monad. The Ivory monad has the type

\begin{code}
Ivory (eff :: Effects) a
\end{code}

\noindent
and is a wrapper for a writer monad transformer over a state monad. The writer
monad writes statements into the Ivory abstract syntax tree, and the
state monad is used to generate fresh names for variables.

\lee{note in particular that effects can be ``turned on'' and ``turned off''}
\paragraph{Effects}
The \cd{eff} type parameter of the Ivory monad is a phantom type that tracks
effects in the Ivory monad at the type level. (These effects have no relation to
the recent work on effects systems for monad transformers~\cite{effects}.)
Currently, we track three classes of effects for a given monadic code block:

\begin{itemize}
\item \emph{Returns}: does the code block contain a \cd{return} statement, and
  is the type of the returned value correct?
\item \emph{Breaks}: does the code block contain a \cd{break} statement?
\item \emph{Allocation}: does the code block contain local memory allocation?
\end{itemize}

Intuitively, these effects matter because their safety depends on the context in
which the monad is used. For example, a \cd{return} statement is safe when used
within a procedure, to implement a function return. But an Ivory code block can
also be used to implement an operating system task that should never
return. Similarly in Ivory, \cd{break} statements are used to terminate
execution of an enclosing loop. (The other valid use of \cd{break} in C99 is to
terminate execution in a \cd{switch} block, but Ivory does not contain
\cd{switch}.) By tracking break effects, we can ensure that an Ivory block
containing a \cd{break} statement is not used outside of a loop. Finally,
allocation effects are used to guarantee that a reference to locally-allocated
memory is not returned by a procedure, which would result in undefined behavior; see
Section~\ref{sec:ref} for details. Moreover, from a code block's type alone, we
can determine whether it allocates memory, simplifying tasks like stack usage
analysis.
\jamey{We don't have a coherent story for stack usage analysis as far as I can
tell. Can we give a more compelling example of the value of tracking local
allocation effects?}

The Ivory effects system is essentially implemented by a type-level tuple
structure where each of the three effects correspond to a field of the
tuple. Type equality constraints enforce that a particular effect is (or is not)
allowed in a give function signature.

The type-level tuple is implemented using data kinds~\cite{data-kinds}. Effects have the
kind \cd{Effects}, containing a single type constructor, \cd{Effects}. The type
constructor \cd{Effects} is parameterized by the fields of the tuple,
representing the respective effects. Using GHC's data kinds extension to lift
data type declarations to data kind declarations,
\begin{code}
data Effects = Effects ReturnEff BreakEff AllocEff
\end{code}

\noindent
Consider the return effects type, \cd{ReturnEff}.  Again using the data kinds
extension to define a new kind and its types, we define two types denoting
whether returns are permitted or not.

\begin{code}
data ReturnEff = forall t. Returns t | NoReturn
\end{code}

\noindent
The type is existentially quantified, since in the case of permitted returns, we
parameterize the type constructor with the type of the value being returned.

A type family~\cite{typefamilies} is used to access and modify the types at each field of
the tuple. To access that field, a type family rewrites the \cd{Effects} type to
the return effect type \cd{ReturnEff}.

\begin{code}
type family   GetReturn (effs :: Effects) :: ReturnEff
type instance GetReturn ('Effects r b a) = r
\end{code}

\noindent
(The GHC syntax is to precede a data kind type constructor with a tick (\cd{'})
to disambiguate it from the corresponding data constructor.)

To modify the field, another type family rewrites it. For example,

\begin{code}
type family   ClearReturn (effs :: Effects) :: Effects
type instance ClearReturn ('Effects r b a) =
  'Effects 'NoReturn b a
\end{code}

With this machinery, we can now use a type equality constraint to enforce
particular effects in a context. For example, the type of \cd{ret}, the smart
constructor for returning a value from a procedure, has the following type
(additional type constraints are elided):

\begin{code}
ret :: (GetReturn eff %*\mytilde*) Returns r, ...)
    => r -> Ivory eff ()
\end{code}

\subsection{Memory Management}
\label{sec:ref}

Ivory uses regions for memory management.  When data is allocated, a reference
to the resulting data is returned, and tagged by the containing region using a
type variable.  Well-typed Ivory programs guarantee that references do no
persist beyond the scope of their containing region.  Regions in Ivory classify
global data, and data allocated and freed on procedure entry/exit (the back-end
relies on stack-based allocation in C), through the language could be modified
to separate the two concepts, as discussed in section~\ref{sec:sem-discuss}.
Corresponding to these two kinds of regions are the region tags that Ivory
supports: \cd{Global} which holds statically-allocated global data that is
available for the lifetime of the program, and a local region unique to each
procedure whose lifetime is tied to that of the procedure.

Data with \cd{Global} scope is allocated through the use of the \cd{area}
top-level declaration, then converted to a reference through the use of the
\cd{addrOf} function.  As the \cd{area} function produces a top-level
declaration, it also requires a symbol to use as the name of the allocated
memory.  Data allocated within a procedure is allocated through the use of the
\cd{local} function, and are tagged with the region of that function.  Since
procedure definition introduces a fresh region, with the constraint that no
reference allocated in that region should should up in the return type of that
procedure, Ivory avoids the introduction of dangling pointers.  The embedding of
this feature in Haskell will be described in more detail in
section~\ref{sec:proc}.

Both forms of allocation take initializers, though \cd{Global} allocation
through \cd{area} will default to zero-initialization if it is omitted.
Initializers are functions that embed values into a structure that mirrors that
of a memory area.  As an example, the \cd{example} value in
figure~\ref{sec:mem-alloc} defines an initializer for an array of three
\cd{Uint8} values.  The types of the allocation functions, as well as a sample
of the initializers available are given in figure~\ref{fig:mem-alloc}.

\begin{figure}
\begin{code}
local  :: (GetAlloc eff %*\mytilde*) 'Scope s, IvoryArea area)
       => Init area -> Ivory eff (Ref s area)

data MemArea (area :: Area *)
area   :: (IvoryArea area)
       => Sym -> Maybe (Init area) -> MemArea area
addrOf :: (IvoryArea area)
       => MemArea area -> Ref Global area

data Init (area :: Area *)
izero  :: IvoryZero area => Init area
ival   :: IvoryType val  => val -> Init (Stored val)
iarray :: IvoryArea area
       => [Init area] -> Init (Array n area)

example :: Init (Array 3 (Stored Uint8))
example  = iarray (map ival [1,2,3])
\end{code}
\caption{Memory allocation and initialization functions}
\label{fig:mem-alloc}
\end{figure}

As noted in section~\ref{sec:ivory-monad}, allocation is tracked through an
effect in the effect context of the Ivory monad.  The result of this is that
each call to the \cd{local} allocation function produces references that are
tied to that specific context.  Conversely, if the current effect context has
no allocation scope, there is no way to produce a new reference.  As allocation
that takes place at the top-level is implicitly in the \cd{Global} region, there
is no need to involve the Ivory monad.

Once a reference has been acquired, it may be stored to and read from in the
context of the Ivory monad using the \cd{store} and \cd{deref} commands.  The
Ivory monad does not track effects for manipulating specific references, and
instead allows reading and writing to any reference that is in scope, within the
context of the Ivory monad.

\subsection{Memory Areas}
\label{sec:area}

In addition to being parameterized on the region they are allocated in,
references are parameterized by the layout of the memory they point to.  We
introduce area types through the \cd{Area} \footnote{ The type parameter on the
\cd{Area} kind is present so that when giving kind-signatures, we can fix the
kind of stored-values as being star (\cd{*})-kinded.  As Haskell currently lacks
a construct for defining kinds without data, this parameterization is necessary,
as kinds are specified with a syntax that is invalid where a type is expected.
This technique was described by Magalh\~{a}es~\cite{jpm:trkgp:12}.} kind, and
the four types that inhabit it (Figure~\ref{fig:area-def}).  This typing of
memory is heavily inspired by the work of Diatchki and Jones~\cite{memareas}.
Ivory supports four kinds of areas that we explain below: arrays with statically
known size, ``C'' arrays without statically known size (for communicating with
external C functions), structs, and stored atomic values.

\lee{discuss lack of sum types somewhere?}

\begin{figure}[h]
\begin{code}
data Area k = Array Nat (Area k)
            | CArray (Area k)
            | Struct Symbol
            | Stored k


store :: IvoryStore a
      => Ref s (Stored a) -> a -> Ivory eff ()
deref :: IvoryStore a
      => Ref s (Stored a) -> Ivory eff a

data Label (struct :: Symbol) (area :: Area *)
(%*\mytilde*)>) :: Ref s (Struct sym) -> Label sym a -> Ref s a
(!)  :: Ref s (Array n area) -> Ix n -> Ref s area
\end{code}
\caption{The definition of the \cd{Area} kind, and associated operations}
\label{fig:area-def}
\end{figure}

\paragraph{Stored values}
The simplest type of memory area is a single base type, lifted to the \cd{Area}
kind by the use of the \cd{Stored} type constructor.  For example, the area type
of a \cd{Sint32} would simply be \cd{Stored Sint32}. The \cd{store} and
\cd{deref} operators will only operate over references that point to \cd{Stored} areas,
mirroring the operations from~\cite{memareas}, as this allows us to never deal
directly with a value of type \cd{Array}, or \cd{Struct}; we only ever read and
write references to values, never references to aggregate values.

As the \cd{Stored} area-type allows the lifting of any star-kinded type to a
memory area, we constrain the operations on references to restrict what is
storable.  This constraint is enforced via the \cd{IvoryStore} class.  While the
\cd{IvoryStore} constraint is used to rule out most types from being stored in a
reference, it is worth noting that it is used to prohibit the storing of other
references.  The reason for this restriction is twofold:
\begin{enumerate}
\item   There is no good
way of requiring initializers when a reference-to-reference is allocated.
\lee{I'd explain this problem in more detail. It's because of nested structures
  and our use of default initializers}
\item The lifetime of a reference is not known when it can be
communicated out via a reference-to-reference procedure argument.
\end{enumerate}

\lee{Perhaps the following fits best in a discussion later in the paper
  (wherever Simon's stuff lives)}
Point (1) could most likely be addressed by adding a concept of a minimal
initializer for each area-type, while point (2) could be addressed in multiple
ways, such as Rust's borrow-checker~\cite{rust}, or Cyclone's region
inference~\cite{cyclone}, though we may give up detection of region errors at
Haskell type-checking time to do so.

\paragraph{Structs} A reference that has an area-kind of type \cd{Struct "x"}
will point to memory whose layout corresponds to the definition of the struct
with name ``x''.  Struct definitions are introduced through use of the ivory
quasi-quoter~\cite{quoted}.  For example, if a region of memory is typed using
the following struct declaration, it would have type \cd{Struct "a"}.

\begin{code}
[ivory| struct a { field1 :: Stored Sint32
                 , field2 :: Struct "b"
                 }
|]
\end{code}

Also introduced by the struct declaration are field labels.  Field labels allow
for indexing into a memory area, producing a reference to the value contained
within the struct.  For example, using the previous struct definition, the
quasi-quoter introduces two labels, \cd{field1} and \cd{field2}, for accessing
those fields given a reference to an ``\cd{a}'' struct:

\begin{code}
field1 :: Label "a" (Stored Sint32)
field2 :: Label "a" (Struct "b")
\end{code}

Using a struct label to select the field of a structure requires the use of the
\cd{(\mytilde>)} operator, which expects a reference to a structure as its first
argument, and a compatible label as its second.  The type of the
\cd{(\mytilde>)} operator is given in figure~\ref{fig:area-def}.  In the
following example, the \cd{(\mytilde>)} operator is used with a reference to an
``\cd{a}'' struct, with the \cd{field1} label, producing a new reference of type
\cd{Ref Global (Stored Sint32)}.

\begin{code}
example :: Ref Global (Struct "a")
        -> Ref Global (Stored Sint32)
example ref = ref %*\mytilde*)> field1
\end{code}

Operations for indexing are pure in Ivory, as they only manipulate a base
pointer; the value of a reference is never dereferenced until an explicit use of
the \cd{deref} primitive, which is an effectful operation.

\paragraph{Arrays}
Arrays in Ivory take two type parameters: the length of the array as a
type-level natural number, and the area type of its elements.  For example, an
array of 10 \cd{Sint32} would have the type \cd{Array 10 (Stored
Sint32)}.  Indexing into arrays is accomplished through the use of the \cd{(!)}
operator, shown in figure \ref{array-support-functions}.

An index into an array has the type \cd{Ix}, which is parameterized by the size
of the array that it is indexing into.  The \cd{Ix n} type will only hold
values between zero and \cd{n-1}, which allows us to avoid run-time array bounds
checks~\cite{memareas}.  One shortcoming of this approach is that the
\cd{(!)} operator will only accept indexes that are parameterized by the length
of the array being indexed, while it would be useful to allow indexes that have
a maximum value that is less than the length of the target array.

As array indexes are parameterized by the length of arrays they can index into,
they become an interesting target for new combinators.  In this vein, we
introduce \cd{arrayMap}, whose signature is shown in figure
\ref{array-support-functions}.  The intuition for the \cd{arrayMap} function is
that it invokes the function provided for all indexes that lie between $0$ and
$n - 1$.  As the index argument given to the function is most often used with an
array, type information propagates out from uses of the \cd{(!)} operator, and
it becomes unnecessary to give explicit bounds for the iteration.

\begin{figure}[h]
\begin{code}
arrayMap :: (Ix n -> Ivory eff a) -> Ivory eff a
toCArray :: Ref s (Array n area) -> Ref s (CArray area)
arrayLen :: Num len => Ref s (Array n area) -> len
\end{code}
\caption{Array support functions}
\label{array-support-functions}
\end{figure}

For compatibility with C, we also introduce a type for arrays that are not
parameterized by their length, \cd{CArray}.  There are no operations to work
with references to \cd{CArray}s in Ivory, as the assumption is that they will
only ever be used when interacting with external C functions.  As many C
functions that consume arrays require both a pointer and a length, we also
provide the \cd{arrayLen} function, which allows the length of an Ivory array to
be demoted to a value.  When used in conjunction with \cd{toCArray}, this
function allows for fairly seamless integration with external C code.

\subsection{Types}
\label{sec:types}

Ivory uses two type classes to define its domain: \cd{IvoryType} and
\cd{IvoryArea}.  \cd{IvoryType} classifies all types that make up valid Ivory
programs.  As Ivory programs build up the AST of the program they represent when
they are run, this class describes the set of types that contain fragments of
the Ivory AST.  The \cd{IvoryArea} class serves to ensure that primitive types
that are stored in references also have an instance of \cd{IvoryType}.  Types
that have \cd{IvoryType} instances include signed and unsigned integers, the
void type \cd{()}, and references, while types that have an \cd{IvoryArea}
instance are limited to those that have kind \cd{Area}, defined in
section~\ref{sec:area}.  See figure~\ref{fig:types} for a sample of the
instances present for these two classes.

\begin{figure}
\begin{code}
class IvoryType a
instance IvoryType Uint32
instance IvoryType Sint32
instance IvoryType ...
instance IvoryArea area => IvoryType (Ref s area)

class IvoryArea (area :: Area *)
instance IvoryType a => IvoryArea (Stored a)
instance IvoryArea e => IvoryArea (Array n e)
instance IvoryArea ...
\end{code}
\caption{Sample instances for \cd{IvoryType} and \cd{IvoryArea}}
\label{fig:types}
\end{figure}

The \cd{IvoryVar} and \cd{IvoryExpr} class further stratify Ivory types that
have values.  The \cd{IvoryVar} class describes all types that can have an Ivory
expression extracted from them, as well as be created from a single variable.
This roughly corresponds to types that can be used as an L-value in assigments,
but also includes types that are to be used as arguments to functions.
The \cd{IvoryExpr} class includes types that can be constructed from full
expressions, and corresponds to the set of types whose values can be used in the
position of an R-value.  It might be tempting to say that the functionality of
the \cd{IvoryVar} belongs in the \cd{IvoryType} class, however as Ivory has a
void type, \cd{()}, we do require this distinction so that we can prevent void
values from being created.

\jamey{What's the distinction between \cd{IvoryVar} and \cd{IvoryExpr}?}

\subsection{Procedures}
\label{sec:proc}

Ivory procedures differ from Haskell functions in that they behave as compiled
procedures, not macros; Haskell functions that produce \cd{Ivory} values will be
expanded at compile time, while Ivory procedures will be translated into
procedures in the target language.  Procedures in Ivory inhabit the \cd{Def}
type which is parameterized by the signature of the function it names.
Procedure signatures inhabit the \cd{Proc} kind, which provides one type
constructor: \cd{:->}.  The \cd{:->} type constructor takes two arguments: the
types of the argument list, and the return type of the whole procedure.  As the
intent behind the use of the \cd{:->} type is to suggest that all of the
arguments to the left of the arrow must be provided before a result may be
produced.

\paragraph{Definition}

Procedures are defined through the use of the \cd{proc} function, which requires
two arguments: a symbolic name for the generated procedure and its
implementation.  The implementation takes the form of a Haskell function that
accepts Ivory value arguments, and produces a result in the Ivory monad.  Again,
viewing Haskell functions that produce values in the Ivory monad as macros, the
\cd{proc} function can be seen as operating at the meta-level, accepting a
symbol name and macro as its arguments, and producing a procedure with the given
name, and the fully-applied macro as its body.  Correct procedure definition is
guarded by the \cd{IvoryProcDef} class, shown in figure~\ref{fig:proc-defs},
which constrains uses of the \cd{proc} function.

\cd{IvoryProcDef} has two parameters: signature and implementation, which relate
the \cd{Proc} type of the resulting Ivory procedure and the Haskell function
given as the its implementation.  There are only two instances for
\cd{IvoryProcDef}: the case where the argument list is empty, and the case where
the argument list is extended by one argument, corresponding to the cases for
the \cd{'[]} and \cd{(':)} type constructors.  The latter case also requires
that the argument added be an Ivory type that is inhabited by a use of the
\cd{IvoryVar} constraint.  In addition to ensuring that the argument type is
acceptable as an argument to an Ivory function, the use of the \cd{IvoryVar}
constraint also allows values to be manufactured from fresh names, allowing
dummy values to be passed to the implementation function.

Examining the functional dependencies for the \cd{IvoryProcDef} class from
figure~\ref{fig:proc-defs}, we see that the implementation function (\cd{impl})
determines the signature of the resulting procedure (\cd{sig}).  The effect of
this dependency in the context of the \cd{proc} function is that the user will
rarely need to write an accompanying \cd{Def} signature for Ivory procedures
they define; uses of the arguments to a procedure will often yield a monomorphic
implementation function, which through the functional dependency will produce a
monomorphic \cd{Def} type.

The implementation function is required to produce a value of type \cd{Body r},
which is simply an Ivory monadic action with its allocation context hidden, and
return type exposed as the type variable \cd{r}.  The \cd{Body} type serves two
purposes: it removes the need to write an instance of \cd{IvoryProcDef} that
involves a rank-2 function, and it defines an extension point for modifying the
body of the procedure.  Pre and post conditions can be added to a procedure body
by the use of the \cd{requires} and \cd{ensures} functions, respectively.  Both
functions allows arbitrary Ivory statements to be added, but disallows all
effects.  The result of this restriction is that memory can be read and
validated, but control flow and allocation effects are prohibited.

The procedure body can be defined through the use of the \cd{body} function,
whose signature is shown in figure~\ref{fig:proc-defs}, lifts an Ivory
computation that returns a result \cd{r} and allocates data in a region \cd{s}
into a value of type \cd{Body r}.  As the allocation scope expected by the Ivory
computation given is quantified in a rank-2 context to the \cd{body} function,
it is not permitted to show up in the type of the result, \cd{r}.  This behavior
allows us to prevent anything allocated within the implementation function from
being returned, a source of dangling pointer bugs.  This is the same technique
used by Launchbury and Peyton Jones~\cite{stmonad} to prevent mutable state
from leaking out of the context of the run function for the \cd{ST} monad.

For example, the procedure \cd{f} defined in figure~\ref{fig:proc-def}, will
produce a type error, as it attempts to return a locally-allocated reference;
references are parameterized by the scope they were allocated in, and as that
scope variable is quantified in the rank-2 context of the argument to the
\cd{body} function that reference is prevented from showing up in the return
type of the procedure, \cd{r}.

\begin{figure}[h]
\begin{code}
f = proc "f" $ body $ do
  ref <- local (izero :: Init Sint32)
  ret ref
\end{code}
\caption{Attempted creation of a dangling pointer}
\label{fig:proc-def}
\end{figure}

\paragraph{Invocation} Procedures are invoked directly through the use of the
\cd{call} function or indirectly through the \cd{invoke} function, both of which
take a \cd{Def} as their first argument, using its signature to determine the
arguments needed.  The arguments needed are determined by the \cd{IvoryCall}
class, which uses the signature information to produce a continuation that
requires parameters that match the type of the argument list from the signature
of the \cd{Def}.  The \cd{IvoryCall} class mirrors the structure of the
\cd{IvoryProcDef} class in instance structure, though it adds one additional
parameter: \cd{eff}.  This additional parameter is required so that the
containing effect context of the call can be connected to the result of the
continuation generated by the instances of \cd{IvoryCall}.  For example, calling
a procedure with type \cd{Def ('[Sint32] :-> Sint32)} will produce a
continuation of the type, \cd{Sint32 -> Ivory eff Sint32}, where the \cd{eff}
parameter is inherited from the current environment.

\begin{figure}[h]
\begin{code}
data Proc k = [k] :-> k

class IvoryProcDef (sig :: Proc *) impl | impl -> sig
instance IvoryProcDef ('[] :-> r) (Body r)
instance IvoryProcDef (as :-> r) impl
  => IvoryProcDef ((a ': as) :-> r) (a -> impl)

class IvoryCall eff (sig :: Proc *) impl
  | sig eff -> impl, impl -> eff
instance IvoryCall eff ([] :-> r) (Ivory eff r)
instance (IvoryExpr a, IvoryCall eff (as :-> r) impl)
  => IvoryCall eff ((a ': as) :-> r) (a -> impl)

body :: (forall s. Ivory (ProcEffects s r) () -> Body r

data Def (sig :: Proc *)
proc :: IvoryProcDef sig impl
     => Sym -> impl -> Def sig

call :: IvoryCall sig eff impl => Def sig -> impl
\end{code}
\caption{Function definition support}
\label{fig:proc-defs}
\end{figure}

\subsection{Strings}
Ivory's support for character strings builds upon the fixed-size array
data type to implement an "array with fill pointer" mechanism, as opposed
to traditional C-style null-terminated strings.

A string value is a structure containing two fields: the data array
with its type-level natural number parameter indicating the maximum
capacity of the string, and an integer field containing the number of
valid characters in the string, up to the capacity.

In figure \ref{ivory-string-type-defn}, we define two example
string types: \cd{Name} is defined with a capacity of 40
characters, and \cd{Phone} with a capacity of 10 characters.

\begin{figure}[h]
\begin{code}
[ivory| struct name
    { name_data   :: Array 40 (Stored Uint8)
    ; name_length :: Stored Sint32
    }

  struct phone
    { phone_data   :: Array 10 (Stored Uint8)
    ; phone_length :: Stored Sint32
    }
|]

type Name  = Struct "name"
type Phone = Struct "phone"
\end{code}
\caption{Definition of two Ivory string types}
\label{ivory-string-type-defn}
\end{figure}

Despite their common structure, the \cd{Name} and \cd{Phone} types
are completely distinct. In order to provide standard library
functions that operate over strings with different capacities in a generic
way, we capture this common structure in the \cd{IvoryString} type
class, defined here in figure \ref{ivory-string-class}.

\begin{figure}[h]
\begin{code}
class IvoryString a where
  type Capacity a :: Nat
  stringDataL   :: Label (StructName a)
                         (Array (Capacity a)
                                (Stored Uint8))
  stringLengthL :: Label (StructName a)
                         (Stored Sint32)
\end{code}
\caption{The \cd{IvoryString} type class}
\label{ivory-string-class}
\end{figure}

The \cd{IvoryString} type class ties together the type-level natural
number containing the array's capacity along with structure field accessors
for the data array and length field. The instance declarations for \cd{Name}
and \cd{Phone} are trivial, as shown in figure \ref{ivory-string-instances}.

\begin{figure}[h]
\begin{code}
instance IvoryString Name where
  type Capacity Name = 40
  stringDataL = name_data
  stringLengthL = name_length

instance IvoryString Phone where
  type Capacity Phone = 10
  stringDataL = phone_data
  stringLengthL = phone_length
\end{code}
\caption{\cd{IvoryString} instances for the \cd{Name} and \cd{Phone}
string types.}
\label{ivory-string-instances}
\end{figure}

With these instances in place, we are able to provide standard library
functions that operate on strings of any capacity, without losing any
type-level information about the capacity of the internal array. For
example, to return the length of any Ivory string, we define the
\cd{istr\_len} function as follows:

\begin{code}
-- Return the length of any Ivory string.
istr_len :: IvoryString a
         => ConstRef s a -> Ivory eff Sint32
istr_len s = deref (s %*\mytilde*)> stringLengthL)
\end{code}

The process of defining string types that only differ
in their maximum capacity can be automated by the Ivory quasiquoter,
allowing us to define these types in a single line each:

\begin{code}
[ivory|
  string struct Name 40
  string struct Phone 10
|]
\end{code}

\subsection{Bit-Data}

\paragraph{Motivation}
Describe scenarios in which we need bit data like features. Low level network
and hardware programming, for example. Outline how Ivory implements a data
definition language at the bit level based on the paper by Iavor et al.

\paragraph{BitRep}
Ivory's type system supports a set of unsigned integer types with
specific bit sizes (8, 16, 32, and 64 bits), as in the C language.
In order to support bit data of arbitrary width (up to the maximum
supported length of 64 bits), we use a type family
\cd{BitRep n} to map an integer size in bits to the smallest
concrete Ivory type that can hold an integer of that size:

\begin{code}
type family BitRep (n :: Nat) :: *
type instance BitRep 1 = Uint8
type instance BitRep 2 = Uint8
{- ... -}
type instance BitRep 9 = Uint16
type instance BitRep 10 = Uint16
{- ... -}
type instance BitRep 64 = Uint64
\end{code}

\paragraph{The "Bits" Type}
Ivory adds additional type safety to arbitrary width integers by
wrapping these values in an opaque type \cd{Bits n}.
Haskell's module system is used to hide the raw constructor for
these values, only permitting valid values to be created via the
use of smart constructors:

\begin{code}
newtype Bits (n :: Nat) = {- Bits (BitRep n) -}

-- | Return a bit value of all zeros.
zeroBits :: Bits n
-- | Convert an Ivory integer to a bit value.
repToBits :: BitRep n -> Bits n
-- | Convert a bit value to an Ivory value.
bitsToRep :: Bits n -> BitRep n
\end{code}

Smart constructors that are partial due to narrowing,
such as \cd{repToBits}, automatically mask out any bits that are
out of range. It is also possible to define runtime-checked versions
of these functions that treat such "junk values" as an error.

\paragraph{BitData Type Class}
To support combining multiple bit fields into a single value, we
generalize the "bit data" concept with a type class \cd{BitData}
that captures the interface of a value that may be converted to
and from its representation as raw bits:

\begin{code}
class BitData a where
  -- | The base 'Bits n' type for this data.
  type BitType a :: *
  -- | Convert a bit data type to its raw bit value.
  toBits :: a -> BitType a
  -- | Convert a raw bit value to this bit data type.
  fromBits :: BitType a -> a

-- | A 'Bits n' value is a trivial instance of 'BitData'.
instance BitData (Bits n) where
  type BitType (Bits n) = Bits n
  toBits   = id
  fromBits = id
\end{code}

\paragraph{BitData Sum Types}
Show how we can define a bit data type as a sum type with specific
bit patterns for each value.

\begin{code}
[ivory|
  bitdata BaudRate :: Bits 2
    = baud_9600    as 0b00
    | baud_19200   as 0b01
    | baud_38400   as 0b10
    -- bit pattern 0b11 is invalid
|]
\end{code}

\paragraph{BitData Product Types}
Show how to assemble a larger bit data type from a set of primitive
and user-defined bit data types.  We'll use an explicit layout clause
as well to show that off.

TODO: Can we include a figure of what this register might look like
in a datasheet here?

%\begin{bytefield}{8}
%  \bitheader{0-8} \\
%  \bitbox{4}{Reserved} & \bitbox{1}{TX\_ENABLE} &
%   \bitbox{1}{RX\_ENABLE} & \bitbox{2}{BAUD\_RATE}
%\end{bytefield}

\begin{code}
[ivory|
  bitdata CtrlReg :: Bits 8 = ctrl_reg
    { ctrl_tx_enable  :: Bit
    , ctrl_rx_enable  :: Bit
    , ctrl_baud_rate  :: BaudRate
    } as 0b0000 # ctrl_tx_enable # ctrl_rx_enable
                # ctrl_baud_rate
|]
\end{code}

\paragraph{Using Bit Data}
Show an example of how to play with individual bits in a register, and how
to set nested/multi-bit fields. Also tackle the issue of converting the
bit data value to/from its representation.

\subsection{Module System}

As seen in Section~\ref{sec:ivory-overview}, Ivory's module system packages up
the collection of procedures, data declarations, and dependencies to be passed
to a back-end, such as the C code generator. The module system is implemented as
a writer monad that produces a list of abstract syntax values that are processed
by the various back-ends.

Because our primary backend is C, Ivory modules respect some of the conventions
of C modules in which header files are used to specify shared declarations. For
example, declarations can be declared as either public or private, and modules
can depend on other modules.

While Ivory's type system is embedded in GHC's type system and Ivory's language
is the Haskell term language, Ivory's module system cannot be embedded in
Haskell's module system. Thus, the user must deal with both Haskell's module
system and Ivory's orthogonal module system when programming.

At best, forgetting to include an Ivory dependency is an inconvenience. The
inconvenience can be substantial in the case that an inter-module dependency is
omitted. In this case, The Ivory program type-checks. If the dependency missing
is a C~function implementation, for example, C~code is generated and compiles,
but fails during link time. The error does not result in a safety violation, but
in large projects, such as the SMACCMPilot autopilot written in Ivory~\cite{},
the error can take several minutes to detect.

\begin{figure}[h]
\begin{code}
foo :: Def ('[Sint32] :-> Sint32)
foo = proc ``foo'' $ \_ -> body $ ret 0

fooInternal :: Def ('[Ref s (Stored Sint32)] :-> Sint32)
fooInternal = proc ``foo'' $ \ref -> body $ do
 x <- deref ref
 ret x

main :: Def ('[] :-> Sint32)
main = proc ``main'' $ body $ do
 x <- call foo 0
 ret x

cmodule :: Module
cmodule = package ``Evil'' $ do
 incl fooInternal
 incl main
\end{code}
\caption{Unsafe module usage}
\label{fig:unsafe-module}
\end{figure}

Worse, a naive implementation of the module system can lead to safety
violations. For example, consider the program in
Figure~\ref{fig:unsafe-module}. Two procedures, \cd{foo} and \cd{fooInternal}
are defined but given the same string used as the procedure name, used in the
generated C. The Ivory program is type-correct and safe, but by passing
\cd{fooInternal} into the module, it is compiled rather than \cd{foo}. And given
the C99 specification, the program compiles without warnings or errors, since
\cd{0} can be implicitly cast to a pointer to a signed 32-bit
integer.\footnote{In practice, the C we generate does contain a warning, since
  the C we generate contains additional type annotations.} The result is a
null-pointer dereference.

To ensure this does not happen, a simple type-check pass over the Ivory AST is
performed before compilation. The type-check pass ensures that the prototype of
a function matches the types of the arguments.

We describe other approaches to compilation that do not involve an embedded
module system in Section~\ref{sec:conclusion}.







