\section{Ivory Embedding}
\label{sec:ivory-embedding}

\lee{This section will be the heart of the paper, focusing on how we have
  embedded Ivory in Haskell's type system. I expect this to be 3-5 pages and
  probably the most technical. We want to be detailed, but describe things
  general enough that ML, Agda, etc. programmers can understand.
}

\subsection{The Ivory Monad}

\lee{Lee: describe the Ivory monad (not too much to say), then describe
  effects. Make sure to make clear these are monad effects like are popular in
  the literature. Mention inspiration from
  \url{http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf}, but didn't
  follow implementation.}

\lee{Also talk about the use of typeclasses \cd{IvoryVar}, \cd{IvoryExpr},
  etc. and how this allows the user to define custom data, safely.}

Ivory is a monadic language, in which Ivory statements have effects in the Ivory
monad. The Ivory monad has the type

\begin{code}
Ivory (eff :: Effects) a
\end{code}

\noindent
and is a wrapper for a writer monad transformer over a state monad. The writer
monad writes statements into the Ivory abstract syntax tree, and the
state monad is used to generate fresh names for variables.

\paragraph{Effects}
The \cd{eff} type parameter of the Ivory monad is a phantom type that tracks
effects in the Ivory monad at the type level. (These effects have no relation to
the recent work on effects systems for monad transformers~\cite{}.) Currently,
we track three classes of effects for a given monadic code block:

\begin{itemize}
\item \emph{Returns}: does the code block contain a \cd{return} statement?
\item \emph{Breaks}: does the code block contain a \cd{break} statement?
\item \emph{Allocation}: does the code block contain local memory allocation?
\end{itemize}

Intuitively, these effects matter because their safety depends on the context in
which the monad is used. For example, a \cd{return} statement is safe when used
within a procedure, to implement a function return. But an Ivory code block can
also be used to implement an operating system task that should never
return. Similarly in Ivory, \cd{break} statements are used to terminate
execution of an enclosing loop (the other valid use of \cd{break} in C99 is to
terminate execution in a \cd{switch} block; Ivory does not contain
\cd{switch}). By tracking break effects, we can ensure that an Ivory block
containing a \cd{break} statement is not used outside of a loop. Finally,
allocation effects are used to guarantee that a reference to locally-allocated
memory is not returned by a procedure, resulting in undefined behavior; see
Section~\ref{sec:ref} for details. Moreover, from a code block's type alone, we
can determine whether it allocates memory, simplifying tasks like stack usage
analysis.

The Ivory effects system is essentially implemented by a type-level tuple
structure where each of the three effects correspond to a field of the
tuple. Type equality constrains enforce that a particular effect is (or is not)
allowed in a give function signature.

The type-level tuple is implemented using data kinds~\cite{}. Effects have the
kind \cd{Effects}, containing a single type constructor, \cd{Effects}. The type
constructor \cd{Effects} is parameterized by the fields of the tuple,
representing the respective effects. Using GHC's data kinds extension to lift
data type declarations to data kind declarations,
\begin{code}
data Effects = Effects ReturnEff BreakEff AllocEff
\end{code}

\noindent
Consider the return effects type, \cd{ReturnEff}.  Again using the data kinds
extension to define a new kind and its types, we define two types denoting
whether returns are permitted or not.

\begin{code}
data ReturnEff = forall t. Returns t | NoReturn
\end{code}

\noindent
The type is existentially quantified, since in the case of permitted returns, we
parameterize the type constructor with the type of the value being returned.

A type family~\cite{} is used to access and modify the types at each field of
the tuple. To access that field, a type family rewrites the \cd{Effects} type to
the return effect type \cd{ReturnEff}.

\begin{code}
type family   GetReturn (effs :: Effects) :: ReturnEff
type instance GetReturn ('Effects r b a) = r
\end{code}

\noindent
(The GHC convention is to precede a type with a tick (\cd{'}) to disambiguate a
type constructor (with the tick) from the data constructor.)

To modify the field, another type family rewrites it. For example,

\begin{code}
type family   ClearReturn (effs :: Effects) :: Effects
type instance ClearReturn ('Effects r b a) =
  'Effects 'NoReturn b a
\end{code}

With this machinery, we can now use a type equality constraint to enforce
particular effects in a context. For example, the type of \cd{ret}, the smart
constructor for returning a value from a procedure, has the following type
(additional type constraints are elided):

\begin{code}
ret :: (GetReturn eff ~ Returns r, ...)
    => r -> Ivory eff ()
\end{code}


\subsection{References and Allocation}
\label{sec:ref}
Ivory manages allocated data through the use of non-nullable references.
References are represented using the \cd{Ref} type, which takes two parameters:
the scope that it was allocated in, and the type of the memory area it points
to.

All references in Ivory are allocated in one of two scopes, \cd{Global}, or a
fresh local scope, unique to the function that the allocation takes place
within.  References with \cd{Global} scope are allocated through the use of the
\cd{area} top-level declaration, and references allocated within a function are
allocated through the use of the \cd{local} function.  Both can take
initializers, defaulting to zero-initialization when they are omitted.

While references allocated in the \cd{Global} scope are allocated when the
program starts, references allocated in the local scope of a function are stack
allocated, and freed as soon as the function returns.

\subsection{Memory Areas}
In Ivory, data pointed to by references and pointers is described by the {\tt
Area} kind, following Diatchki and Jones' work in \cite{memareas}.  This kind
contains four types: {\tt Stored}, \cd{Struct}, \cd{Array}, and \cd{CArray}.

\begin{figure}[h]
\begin{code}
data Area k = Array Nat (Area k)
            | CArray (Area k)
            | Struct Symbol
            | Stored k
\end{code}
\caption{The definition of the \cd{Area} kind}
\end{figure}

\paragraph{Stored values}
The simplest type of memory area is a single base type, lifted to the \cd{Area}
kind by the use of the \cd{Stored} type constructor.  For example, the area type
of a \cd{Sint32} would simply be \cd{Stored Sint32}.

\paragraph{Structs} A reference that has an area-kind of type \cd{Struct "x"}
will point to memory whose layout corresponds to the definition of the struct
with name x.  Struct definitions are introduced through use of the ivory
quasi-quoter.  For example, if a region of memory is typed using the struct
definition from figure \ref{example-struct}, it would have type \cd{Struct "a"}.

\begin{figure}[h]
\begin{code}
[ivory| struct a { field1 :: Stored Sint32
                 , field2 :: Struct "b"
                 }
      |]
\end{code}
\caption{An example struct definition}
\label{example-struct}
\end{figure}

Also introduced by the struct declaration are field labels.  Field labels allow
for indexing into a memory area, producing a reference to the value contained
within the struct.  For example, using the struct definition from figure
\ref{example-struct}, there would be two labels introduced: \cd{field1}, and
\cd{field2}, and will have types \cd{Label "a" (Stored Sint32)} and \cd{Label
"a" (Struct "b")}, respectively.

Using a struct label to select the field of a structure requires the use of the
\cd{(\mytilde>)} operator, which expects a reference to a structure as its first
argument, and a compatible label as its second.  In figure
\ref{example-struct-label}, the \cd{(\mytilde>)} operator is used with a reference to
an ``a'' struct, with the \cd{field1} label, producing a new reference of type
\cd{Ref Global (Stored Sint32)}

\begin{figure}[h]
\begin{code}
example :: Ref Global (Struct "a")
        -> Ref Global (Stored Sint32)
example ref = ref %*\mytilde*)> field1
\end{code}
\caption{Struct field indexing}
\label{example-struct-label}
\end{figure}

\paragraph{Arrays}
Arrays in Ivory take two type parameters: the length of the array as a
type-level natural number, and the area type of its elements.  For example, an
array of 10 \cd{Sint32} would have the type \cd{Array 10 (Stored
Sint32)}.  Indexing into arrays is accomplished through the use of the \cd{(!)}
operator, shown in figure \ref{array-support-functions}.

An index into an array has the type \cd{Ix}, which is parameterized by the size
of the array that it is indexing into.  The \cd{Ix n} type will only hold
values between zero and \cd{n-1}, which allows us to avoid run-time array bounds
checks, as in \ref{memareas}.  One shortcoming of this approach is that the
\cd{(!)} operator will only accept indexes that are parameterized by the length
of the array being indexed, while it would be useful to allow indexes that have
a maximum value that is less than the length of the target array.

As array indexes are parameterized by the length of arrays they can index into,
they become an interesting target for new combinators.  In this vein, we
introduce \cd{arrayMap}, whose signature is shown in figure
\ref{array-support-functions}.  The intuition for the \cd{arrayMap} function is
that it invokes the function provided for all indexes that lie between $0$ and
$n - 1$.  As the index argument given to the function is most often used with an
array, type information propagates out from uses of the \cd{(!)} operator, and
it becomes unnecessary to give explicit bounds for the iteration.

\begin{figure}[h]
\begin{code}
(!)      :: Ref s (Array n area) -> Ix n -> Ref s area
arrayMap :: (Ix n -> Ivory eff a) -> Ivory eff a
toCArray :: Ref s (Array n area) -> Ref s (CArray area)
arrayLen :: Num len => Ref s (Array n area) -> len
\end{code}
\caption{Array support functions}
\label{array-support-functions}
\end{figure}

For compatibility with C, we also introduce a type for arrays that are not
parameterized by their length, \cd{CArray}.  There are no operations to work
with references to \cd{CArray}s in Ivory, as the assumption is that they will
only ever be used when interacting with external C functions.  As many C
functions that consume arrays require both a pointer and a length, we also
provide the \cd{arrayLen} function, which allows the length of an Ivory array to
be demoted to a value.  When used in conjunction with \cd{toCArray}, this
function allows for fairly seamless integration with external C code.

\subsection{Procedures}
Procedures in Ivory inhabit the \cd{Def} type which is parameterized by the
signature of the function it names.  Procedure signatures inhabit the \cd{Proc}
kind, which provides one type constructor: \cd{:->}.  The \cd{:->} type
constructor takes two arguments: the types of the argument list, and the return
type of the whole procedure.  To enable processing using type classes while
easing the burden on the programmer, the argument list is specified as a
type-level list of $*$-kinded types.  This enables the definition of three
classes that are used in the definition and invocation of procedures.

\paragraph{Definition} Procedures are defined through the use of the \cd{proc}
function, which requires two arguments: a symbolic name for the function, and
its implementation.  The implementation takes the form of a Haskell function
that operates over Ivory language values, producing a function body result.
Correct procedure definition is guarded by the \cd{IvoryProcDef} class, which
constrains the use of the \cd{proc} function.

\cd{IvoryProcDef} has two parameters: signature and implementation, which relate
the \cd{proc} type of the Ivory procedure and the haskell function given as the
its implementation.  There are only two instances for \cd{IvoryProcDef}: the
case where the argument list is empty, and the case where the argument list is
extended by one argument.  The latter case also requires that the argument added
be an Ivory type (via the \cd{IvoryExpr} class), thus guaranteeing that values
can be generated to pass to the implementation function.   As the signature of
the resulting \cd{Def} is fully determined by the implementation function
through the functional dependency from impl to proc in the class definition of
\cd{IvoryProcDef}, users are only required to write signatures when the
implementation given to \cd{proc} is ambiguous.

The implementation function is required to produce a final value of the type
\cd{Body r}, where \cd{r} is the return type of the function.  Values of type
\cd{Body} are created through the use of three functions: \cd{requires},
\cd{ensures}, and \cd{body}.  The \cd{requires} function allows the programmer
to state requirements of the arguments to the function, while \cd{ensures}
allows the programmer to state properties that the function should preserve. The
third function \cd{body}, whose signature is shown in figure \ref{proc-defs},
lifts an Ivory computation that returns a result \cd{r} and allocates data in a
region \cd{s} into a value of type \cd{Body r}.  As the allocation scope
expected by the Ivory computation given is quantified in a rank-2 context to the
\cd{body} function, it is not permitted to show up in the type of the result,
\cd{r}.  This behavior allows us to prevent anything allocated within the
implementation function from being returned, a source of dangling pointer bugs.
This is the same technique used by Launchbury and Peyton Jones in \cite{stmonad}
to prevent mutable state from leaking out of the context of the run function for
the \cd{ST} monad.

For example, the procedure \cd{f} defined in figure \ref{proc-def}, will produce
a type error, as it attempts to return a locally-allocated reference; as
references have the scope they were allocated in as part of their type, the use
of the \cd{Body} type prevents anything allocated within its context from
escaping out.

\begin{figure}[h]
\begin{code}
f = proc "f" $ body $ do
  ref <- local (izero :: Init Sint32)
  ret ref
\end{code}
\caption{Attempted creation of a dangling pointer}
\label{proc-def}
\end{figure}

\paragraph{Invocation} Procedures are invoked directly through the use of the
\cd{call} function or indirectly through the \cd{invoke} function, both of which
take a \cd{Def} as their first argument, using its signature to determine the
rest of the arguments needed.  The arguments needed are determined by the
\cd{IvoryCall} class, which uses the signature information to produce a
continuation that requires parameters that match the type of the argument list
from the signature of the \cd{Def}.  The \cd{IvoryCall} class mirrors the
structure of the \cd{IvoryProcDef} class in instance structure, though it adds
one additional parameter: \cd{eff}.  This additional parameter is required so
that the containing effect context of the call can be connected to the result of
the continuation generated by the instances of \cd{IvoryCall}.  For example,
calling a procedure with type \cd{Def ('[Sint32] :-> Sint32)} will produce a
continuation of the type, \cd{Sint32 -> Ivory eff Sint32}, where the \cd{eff}
parameter is inherited from the current environment.

\trevor{Is there something from Lennart that we can cite about the
implementation of call, as it relates to printf?}

\begin{figure}[h]
\begin{code}
data Proc k = [k] :-> k

class IvoryProcDef (sig :: Proc *) impl | impl -> sig
instance IvoryProcDef ('[] :-> r) (Body r)
instance IvoryProcDef (as :-> r) impl
  => IvoryProcDef ((a ': as) :-> r) (a -> impl)

class IvoryCall eff (sig :: Proc *) impl
  | sig eff -> impl, impl -> eff
instance IvoryCall eff ([] :-> r) (Ivory eff r)
instance (IvoryExpr a, IvoryCall eff (as :-> r) impl)
  => IvoryCall eff ((a ': as) :-> r) (a -> impl)

body :: (forall s. Ivory (ProcEffects s r) () -> Body r

data Def (sig :: Proc *)
proc :: IvoryProcDef sig impl
     => Sym -> impl -> Def sig

call :: IvoryCall sig eff impl => Def sig -> impl
\end{code}
\caption{Function definition support}
\label{proc-defs}
\end{figure}



\lee{Trevor: describe the use of type-level lists to define procedures. Describe
the use of a type-class to ensure procedure calls in Ivory are type-correct.}

\subsection{Strings}
Ivory's support for character strings builds upon the fixed-size array
data type to implement an "array with fill pointer" mechanism, as opposed
to traditional C-style null-terminated strings.

A string value is a structure containing two fields: the data array
with its type-level natural number parameter indicating the maximum
capacity of the string, and an integer field containing the number of
valid characters in the string, up to the capacity.

In figure \ref{ivory-string-type-defn}, we define two example
string types: \cd{Name} is defined with a capacity of 40
characters, and \cd{Phone} with a capacity of 10 characters.

\begin{figure}[h]
\begin{code}
[ivory| struct name
    { name_data   :: Array 40 (Stored Uint8)
    ; name_length :: Stored Sint32
    }

  struct phone
    { phone_data   :: Array 10 (Stored Uint8)
    ; phone_length :: Stored Sint32
    }
|]

type Name  = Struct "name"
type Phone = Struct "phone"
\end{code}
\caption{Definition of two Ivory string types}
\label{ivory-string-type-defn}
\end{figure}

Despite their common structure, the \cd{Name} and \cd{Phone} types
are completely distinct. In order to provide standard library
functions that operate over strings with different capacities in a generic
way, we capture this common structure in the \cd{IvoryString} type
class, defined here in figure \ref{ivory-string-class}.

\begin{figure}[h]
\begin{code}
class IvoryString a where
  type Capacity a :: Nat
  stringDataL   :: Label (StructName a)
                         (Array (Capacity a)
                                (Stored Uint8))
  stringLengthL :: Label (StructName a)
                         (Stored Sint32)
\end{code}
\caption{The \cd{IvoryString} type class}
\label{ivory-string-class}
\end{figure}

The \cd{IvoryString} type class ties together the type-level natural
number containing the array's capacity % (using an associated type \cite{})
along with structure field accessors
for the data array and length field. The instance declarations for \cd{Name}
and \cd{Phone} are trivial, as shown in figure \ref{ivory-string-instances}.

\begin{figure}[h]
\begin{code}
instance IvoryString Name where
  type Capacity Name = 40
  stringDataL = name_data
  stringLengthL = name_length

instance IvoryString Phone where
  type Capacity Phone = 10
  stringDataL = phone_data
  stringLengthL = phone_length
\end{code}
\caption{\cd{IvoryString} instances for the \cd{Name} and \cd{Phone}
string types.}
\label{ivory-string-instances}
\end{figure}

With these instances in place, we are able to provide standard library
functions that operate on strings of any capacity, without losing any
type-level information about the capacity of the internal array. For
example, to return the length of any Ivory string, we define the
\cd{istr\_len} function as follows:

\begin{code}
-- Return the length of any Ivory string.
istr_len :: IvoryString a
         => ConstRef s a -> Ivory eff Sint32
\end{code}

The process of defining string types that only differ
in their maximum capacity can be automated by the Ivory quasiquoter,
allowing us to define these types in a single line each:

\begin{code}
[ivory|
  string struct Name 40
  string struct Phone 10
|]
\end{code}

\subsection{Bit-Data}
\lee{James: talk about using TH to define bitdata.}

\subsection{Maybe Types}
\lee{James: not sure, but maybe this would be useful to have?}

\subsection{Module System}
\lee{Lee: describe the module system, warts and all.}

As seen in Section~\ref{sec:ivory-overview}, Ivory's module system packages up
the collection of procedures, data declarations, etc. to be passed to a
back-end, such as the C code generator. The module system is implemented simply
as a writer monad that produces a list of abstract syntax values that are
processed by the various back-ends.

While the module system implementation is intuitive and simple, it is also one
of the greatest weaknesses of Ivory as an EDSL. \lee{XXX finish}

Values included in a module must be monomorphic; a type error results
otherwise. 

Because of our design decision 

\lee{make sure Pat's section show the Ivory module system.}






