\section{Introduction}
\label{sec:introduction}

\lee{also mention in contributions that we've worked on edsl usability?}

There is still a clear need for minimally-managed low-level languages
which provide fine-grained control over memory usage and timing
behavior.  For example, embedded systems typically require a small
resource footprint and predictable interaction with external devices.
Furthermore, such applications also require high levels of assurance,
operating, for example, in environments where human intervention is
undesirable or impossible, or where failure is catastrophic.

In this paper we present the language \emph{Ivory}.  Ivory follows in
the footsteps of other ``safe C'' programming languages, like
Cyclone~\cite{cyclone} and Rust~\cite{rust}. By safe C languages, we
mean languages that avoid many of the pitfalls of C, particularly
related to memory safety and undefined behavior, that are suitable for
writing low-level code (e.g., device drivers). Ivory, like other safe
C languages, has a minimal runtime system.

Ivory is not a toy language: we have used Ivory to write
\emph{SMACCMPilot}~\cite{smaccm}, a full-featured high-assurance
autopilot for a small unpiloted air vehicle.  Furthermore, Boeing has
used Ivory to implement a level-of-interoperability for
Stanag~4586~\cite{stanag}, a unpiloted air vehicle communications
standard. We know of a few additional small projects by other
developers in Ivory, as well.  There are well over 100 KLoC of Ivory.

%% maybe remove?  I wanted to talk briefly about the EDSL aspect, etc.
%% Question this answers: why should I care?  Might be answered in the
%% next bit ...
\sjw{more of a summary paragraph, probably rephrase or remove?}
Ivory is implemented as an EDSL~\cite{edsl} inside the Haskell
language.  Ivory uses advanced features of the GHC implementation of
Haskell to ensure properties such as memory safety.  Ivory supports a
number of reasoning tools.

\paragraph{Contributions}
In 2014, Stephanie Weirich gave a keynote address at the International
Conference on Functional Programming describing dependent programming using
recent type and language extensions of GHC's implementation of Haskell (which we
will colloquially refer to as ``GHC'' in the remainder of this
paper)~\cite{weirich-keynote}. Weirich describes how recent extensions to GHC
provide much of the power of dependently-typed programming, such as found in
Agda~\cite{agda}, Idris~\cite{idris}, or Coq~\cite{coq}. However, in GHC, a surprisingly
powerful subset of dependent typing features can be used while still enjoying
type-inference and decidable type-checking~\cite{dephaskell}.

Ivory exemplifies the use of GHC dependent types in a large, fully-featured
EDSL. A contribution of the language is demonstrating that type checking for
safe programming involving the use of pointers, arrays, loops and local memory
allocation, can be embedded into GHC's type system. Indeed, Ivory's type system
goes beyond mere safety and tracks effects, such as memory allocation and
control flow operators (e.g., \cd{break} and \cd{return} statements).

After providing a brief introduction to the Ivory language in
Section~\ref{sec:ivory-overview}, we describe Ivory's embedding in GHC's type
system in Section~\ref{sec:ivory-embedding}, obviating the need for a writing a
custom type-checker or compiler for a safe C language.

Embedding a type system for a safe C language into GHC's type system is tricky
business. To gain confidence that our embedding is correct, we have formalized a
model of Ivory in the Isabelle theorem prover~\cite{isabelle}, and used the model to
formally prove progress and preservation properties for Ivory. In the process,
we have discovered minor bugs in Ivory's type embedding in GHC as well as
generalizations to Ivory that still preserve safety. We describe the
formalization, proofs, and extensions in Section~\ref{sec:semantics}.

Ivory goes beyond ensuring memory safety, the focus on most other safe C
programming languages, and also provides automated support for preventing errors
that result from other undefined behaviors in C (e.g., division by zero, left
bit-shifts by a negative value, etc.) as well as support for checking
user-provided assertions. Toward this end, Ivory supports writing user-supplied
assertions and pre- and post-conditions on functions, and includes a built-in
symbolic simulator targeting an SMT solver (CVC4~\cite{cvc4}), as well as an
theorem-prover back-end targeting ACL2~\cite{acl2}. For automated testing, a
QuickCheck-like property-based test-case generator is integrated into
Ivory. These tools are described in Section~\ref{sec:tools}.

Ivory is open-source (BSD3 license) and available at \url{ivory-lang.org}. 