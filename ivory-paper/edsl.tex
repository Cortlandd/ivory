\section{A Safe-C EDSL}
\label{sec:edsl}

Large-scale, safe~C programming in an EDSL has advantages and disadvantages. In
a previous experience report, we explored some of the benefits of using an EDSL
for embedded system development~\cite{smaccm}. We will not repeat those claims
here. Rather, we describe two problematic aspects we have specifically addressed in Ivory:
(1) integrating a C-like concrete syntax into the EDSL and (2) error-reporting.

\paragraph{Concrete Syntax}

A benefit of the EDSL approach is that it relieves the developer from having to
define and implement a front-end syntax. However, that also generally means that
only users of the host language will be attracted to using the
EDSL. We want C/C++ developers to use Ivory!

\begin{figure}[h!]
\begin{code}
void mapProc(s*uint8_t[4] arr, uint8_t x) {
  map ix {
    let v = arr@ix;
    *v = *v + x;
  }
}
\end{code}
  \caption{Concrete Syntax for Ivory}
  \label{fig:concrete}
\end{figure}

The need for a concrete C-like syntax became evident in our work supporting
Boeing's use of Ivory, mentioned in Section~\ref{sec:introduction}. We have
already seen specific uses of quasi-quotation in Ivory to define a concrete
syntax for structs (Section~\ref{sec:area}) and bit-data
(Section~\ref{sec:bitdata}). In fact, a quasi-quotation is given for the entire
Ivory language. An example quasi-quoted Ivory procedure is shown in
Figure~\ref{sec:control}. The procedure is the equivalent of the procedure with
the same name in Section~\ref{sec:control}.

A quasi-quoted Ivory program is guaranteed to be type-safe, since the generated
Haskell program is type-checked. an important feature of the quasi-quoted
language is that it automatically generates the appropriate type signatures for
Ivory programs, relieving the programmer from doing so. The quasi-quoter also
generates Ivory modules automatically and guarantees that procedure names match
their Haskell identifiers, obviating the problems discussed in
Section~\ref{sec:modules}. The quasi-quoter supports anti-quotation, so that
Haskell can still be used as a macro language. All of Boeing's development in
Ivory is via the quasi-quoter.

Implementing a quasi-quoter means that we have defined a lexer and parser for
the concrete syntax. Because Ivory is deeply embedded in Haskell, there is a
concrete data type (i.e., the abstract syntax tree (AST)) over which
optimizations and back-ends are implemented. The distance from Ivory as an EDSL
and a stand-alone compiler is surprisingly small, essentially requiring a
type-checker and a front-end targeting the AST directly. In this manner, we are
able to ``grow'' a compiler, from an EDSL to a stand-alone system.

\paragraph{Error Reporting}
Ivory's The use of advanced type-system features can produce elaborate and
confusing type-error messages to the user. Idris~\cite{christiansen2014reflect}
allows the programmer to supply error handlers, which are given a data structure

Statically, the use of advanced type-system features, e.g.\ higher-rank
polymorphism to track memory regions, can in practice produce elaborate and
confusing type-error messages.
\eric{I'm sure there's a better example here than higher-rank polymorphism.}
Idris~\cite{christiansen2014reflect} allows the
programmer to supply error handlers, which are given a data structure

representing the compiler's error message and can rewrite it to insert
domain-specific knowledge. Unfortunately, GHC Haskell does not currently support
such a feature.

%% Thus, the EDSL author can provide custom type-error
%% messages using language the application programmers will understand.

The next best thing is to at least give the user accurate error location
information. Dynamically reporting errors in an EDSL is also made difficult by the lack of
source locations. Consider the Ivory expression \hbox{\cd{x / y},} which induces a
runtime assertion \cd{y != 0}. If the assertion fails, we would like to include
a \emph{Haskell} source location in the error message to direct the programmer to the source of
the error. But how are we to obtain the source location in the first place?
Ivory programs are comprised of Haskell expressions and Haskell is
pure--functions cannot depend on their call-site--so we must look outside the
language proper to obtain source locations. A common approach for writing
location-aware functions in Haskell, epitomized by the \cd{file-location}
package~\cite{file-location}, is to use a Template Haskell splice to query the
compiler for the current source location and insert it into the AST. This
approach did not appeal to us as Template Haskell incurs considerable syntactic
overhead, and we already had 10+ KLoC of Ivory which would all need to be
rewritten.

Instead we opted to write a compiler plugin that rewrites GHC's intermediate
representation to add the source locations. The implementation was
straightforward, we first extended the \cd{Ivory} statement type with a new
\cd{Location} constructor that just contains a location in the Haskell source,
essentially a special type of comment. The plugin then extracts the source
locations from GHC and wraps all actions in the \cd{Ivory} monad with a
\cd{withLocation} function that emits a \cd{Location} statement before executing
the wrapped action. While this effectively limits the location granularity to
lines rather than columns, our approach required only modest changes to the
Ivory compiler and--importantly--no changes to Ivory code. As the plugin
itself requires little knowledge of Ivory, we have abstracted it out into a
separate package~\cite{ghc-srcspan-plugin} that can be reused by other projects.
Furthermore, we have since submitted a lightweight extension to GHC that allows
functions to request their call-site by taking a special implicit
parameter~\cite{lewis2000implicit} as an argument, which should become available
in the 7.12 release.

\lee{Lee: describe line number insertions (overcoming a bad thing), module
  system (hack), the use of TH to make a concrete syntax, macros (e.g., standard
  lib---compare to Rust), other uses of macros, small compiler.}
