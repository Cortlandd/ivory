
module Ivory.Compile.AADL.PrettyPrint where

import Ivory.Compile.AADL.AST
import Text.PrettyPrint.Leijen
import System.IO

tab :: Doc -> Doc
tab = indent 2

documentToFile :: FilePath -> Document -> IO ()
documentToFile f d = withFile f WriteMode $ \h -> displayIO h rendered
  where
  w = 1000000 -- don't wrap lines 
  rendered = renderPretty 1.0 w $ aadlDoc d

aadlDoc :: Document -> Doc
aadlDoc d = vsep $
  [ text "-- AADL Document autogenerated by Ivory.Language.AADL"
  , empty
  , text "package" <+> text (doc_name d)
  , text "public"
  , tab $ vsep $ map docImport (doc_imports d)
  , empty
  , vsep $ map docDefinition (doc_definitions d)
  , empty
  ]

docImport :: String -> Doc
docImport s = text "with" <+> text s <> semi

docDefinition :: Definition -> Doc
docDefinition (TypeDefinition dtypedef)    = docDTypeDef dtypedef   <$> empty
docDefinition (ThreadDefinition threaddef) = docThreadDef threaddef <$> empty

docDTypeDef :: DTypeDef -> Doc
docDTypeDef (DTStruct tname fields) = vsep
  [ docBlock "data" t
      [ docSection "properties"
          [ docKV "Data_Model::Data_Representation" "Struct"
          ]
      ] 
  , empty
  , docBlock "data implementation" ti
      [ docSection "subcomponents"
          (map docDTField fields)
      ]
  ]
  where
  t  = string tname
  ti = t <> dot <> text "impl"

docDTypeDef (DTArray tname len basetype) =
  docBlock "data" t $
    [ dmodel "Data_Representation" $ text "Array"
    , dmodel "Base_Type"           $ parens btype
    , dmodel "Dimension"           $ parens (int len)
    ]
  where
  t = text tname
  dmodel field v = kv (text ("Data_Model::" ++ field)) v
  btype = text "classifier" <+> parens (docTypeName basetype)

docBlock :: String -> Doc -> [Doc] -> Doc
docBlock opener name body = text opener <+> name 
                         <$> tab (vsep body)
                         <$> text "end" <+> name <> semi
                         <$> empty

docSection :: String -> [Doc] -> Doc
docSection secname props = text secname <$> tab (vsep props)

docDTField :: DTField -> Doc
docDTField (DTField name tname) =
  text name <+> colon <+> text "data" <+> docTypeName tname <> semi

docTypeName :: TypeName -> Doc
docTypeName (UnqualTypeName s)   = text s
docTypeName (QualTypeName a b)   = text a <> colon <> colon <> text b
docTypeName (DotTypeName n a)    = docTypeName n <> dot <> text a

docThreadDef :: ThreadDef -> Doc
docThreadDef (ThreadDef threadname features properties) =
  docBlock "thread" t
    [ docSection "features"
        (map docThreadFeature features)
    , docSection "properties"
        (map docThreadProperty properties)
    ]
  where
  t = text threadname

docThreadFeature :: ThreadFeature -> Doc
docThreadFeature (ThreadFeaturePort n k d tname props) =
  text n <> colon <+> dd <+> kk <+> (docTypeName tname) <> ps
  where
  dd = case d of
    In  -> text "in"
    Out -> text "out"
  kk = case k of
    PortKindData  -> text "data port"
    PortKindEvent -> text "event data port"
  ps = case props of
    [] -> empty
    _  -> space <> braces (line <> tab values <> line) <> semi
      where values = vsep (map (uncurry docKV) props)

docKV :: String -> String -> Doc
docKV k v = kv (text k) (text v) 

kv :: Doc -> Doc -> Doc
kv k v = k <+> text "=>" <+> v <> semi

docThreadProperty :: ThreadProperty -> Doc
docThreadProperty (ThreadProperty k v) = docKV k v

