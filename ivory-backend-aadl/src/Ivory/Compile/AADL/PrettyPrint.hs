
module Ivory.Compile.AADL.PrettyPrint where

import Ivory.Compile.AADL.AST
import Text.PrettyPrint.Leijen
import System.IO

tab :: Doc -> Doc
tab = indent 2

documentToFile :: FilePath -> Document -> IO ()
documentToFile f d = withFile f WriteMode $ \h -> displayIO h rendered
  where
  w = 1000000 -- don't wrap lines 
  rendered = renderPretty 1.0 w $ aadlDoc d

aadlDoc :: Document -> Doc
aadlDoc d = vsep $
  [ text "-- AADL Document autogenerated by Ivory.Language.AADL"
  , empty
  , text "package" <+> text (doc_name d)
  , text "public"
  , tab $ vsep $ map docImport (doc_imports d)
  , empty
  , vsep $ map docDefinition (doc_definitions d)
  , empty
  ]

docImport :: String -> Doc
docImport s = text "with" <+> text s <> semi

docDefinition :: Definition -> Doc
docDefinition (TypeDefinition dtypedef)    = docDTypeDef dtypedef   <$> empty
docDefinition (ThreadDefinition threaddef) = docThreadDef threaddef <$> empty

docDTypeDef :: DTypeDef -> Doc
docDTypeDef (DTDeclaration tname) =
  text "data" <+> t <$> text "end" <+> t <> semi
  where t = docTypeName tname
docDTypeDef (DTImplementation tname implname fields) =
      text "data implementation" <+> t
  <$> tab body
  <$> text "end" <+> t <> semi
  where
  t = docTypeName tname <> dot <> text implname
  body =  text "subcomponents"
      <$> tab (vsep (map docDTField fields))

docDTField :: DTField -> Doc
docDTField (DTField name tname) =
  text name <+> colon <+> text "data" <+> docTypeName tname <+> semi

docTypeName :: TypeName -> Doc
docTypeName (UnqualTypeName s)   = text s
docTypeName (QualTypeName a b)   = text a <> colon <> colon <> text b
docTypeName (ArrayTypeName _ _)  = text "(array type rendering unsupported)"
docTypeName (RefTypeName _ _)    = text "(ref type rendering unsupported)"
docTypeName (StructTypeName s)   = text s -- XXX ??
docTypeName (ProcTypeName _ _)   = text "(ref type rendering unsupported)"

docThreadDef :: ThreadDef -> Doc
docThreadDef (ThreadDef threadname features properties) =
      text "thread" <+> t
  <$> tab (text "features")
  <$> tab (tab (vsep (map docThreadFeature features)))
  <$> tab (text "properties")
  <$> tab (tab (vsep (map docThreadProperty properties)))
  <$> text "end" <+> t <> semi
  <$> empty
  where
  t = text threadname

docThreadFeature :: ThreadFeature -> Doc
docThreadFeature (ThreadFeaturePort n k d tname props) =
  text n <> colon <+> dd <+> kk <+> (docTypeName tname) <> ps
  where
  dd = case d of
    In  -> text "in"
    Out -> text "out"
  kk = case k of
    PortKindData  -> text "data port"
    PortKindEvent -> text "event data port"
  ps = case props of
    [] -> empty
    _  -> braces (vsep (empty : map docKV props))

docKV :: (String, String) -> Doc
docKV (k,v) = text k <+> text "=>" <+> text v <> semi

docThreadProperty :: ThreadProperty -> Doc
docThreadProperty (ThreadProperty k v) = docKV (k,v)

